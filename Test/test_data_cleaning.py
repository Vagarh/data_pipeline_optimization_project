# -*- coding: utf-8 -*-
"""Fase 1: Programación Lineal del Proceso de Datos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J4WUlLMGXTnUnuv5AXJBCkUVpWtrmOTY
"""

! pip install tools

import pandas as pd
import numpy as np
import re
import tools



excel_file = pd.ExcelFile('/content/Films_2.xlsx')
print(excel_file.sheet_names)  # Muestra los nombres de las hojas

"""# Extraccion"""

df_film = pd.read_excel(excel_file, sheet_name="film")
df_inventory= pd.read_excel(excel_file, sheet_name="inventory")
df_rental= pd.read_excel(excel_file, sheet_name="rental")
df_customer= pd.read_excel(excel_file, sheet_name="customer")
df_sales= pd.read_excel(excel_file, sheet_name="store")

"""# Experimento 1 Formateo de una sola tabla"""

# Eliminar espacios adicionales en los nombres de las columnas
df_film.columns = df_film.columns.str.strip()

# Limpieza de columnas según el formato esperado

# Columna numérica (elimina caracteres no numéricos y convierte a 'Int64' para permitir NaN)
df_film['film_id'] = df_film['film_id'].astype(str).str.replace(r'[^0-9]', '', regex=True)
df_film['film_id'] = pd.to_numeric(df_film['film_id'], errors='coerce').astype('Int64')

# Columnas de texto (elimina caracteres especiales y espacios en blanco)
df_film['title'] = df_film['title'].astype(str).str.replace(r'[^a-zA-Z0-9\s]', '', regex=True).str.strip()
df_film['description'] = df_film['description'].fillna('').astype(str).str.replace(r'[^a-zA-Z0-9\s]', '', regex=True).str.strip()

# Columna de fechas (limpia y convierte a formato datetime)
df_film['last_update'] = pd.to_datetime(df_film['last_update'].astype(str).str.replace(r'[^0-9\-: ]', '', regex=True), errors='coerce')

# Columna flotante (elimina caracteres no numéricos, excepto el punto decimal, y convierte a float)
df_film['rental_rate'] = df_film['rental_rate'].astype(str).str.replace(r'[^0-9.]', '', regex=True)
df_film['rental_rate'] = pd.to_numeric(df_film['rental_rate'], errors='coerce').astype(float)

# Convertir otras columnas con tipos definidos y manejo de NaN

df_film['release_year'] = df_film['release_year'].astype(str).str.replace(r'[^0-9]', '', regex=True)
df_film['release_year'] = pd.to_numeric(df_film['release_year'], errors='coerce').astype('Int64')

df_film['language_id'] = df_film['language_id'].astype(str).str.replace(r'[^0-9]', '', regex=True)
df_film['language_id'] = pd.to_numeric(df_film['language_id'], errors='coerce').astype('Int64')

df_film['original_language_id'] = pd.to_numeric(df_film['original_language_id'], errors='coerce').astype('Int64')

df_film['rental_duration'] = df_film['rental_duration'].astype(str).str.replace(r'[^0-9]', '', regex=True)
df_film['rental_duration'] = pd.to_numeric(df_film['rental_duration'], errors='coerce').astype('Int64')

df_film['length'] = df_film['length'].astype(str).str.replace(r'[^0-9.]', '', regex=True)
df_film['length'] = pd.to_numeric(df_film['length'], errors='coerce').astype(float)

df_film['replacement_cost'] = df_film['replacement_cost'].astype(str).str.replace(r'[^0-9.]', '', regex=True)
df_film['replacement_cost'] = pd.to_numeric(df_film['replacement_cost'], errors='coerce').astype(float)

df_film['num_voted_users'] = df_film['num_voted_users'].astype(str).str.replace(r'[^0-9]', '', regex=True)
df_film['num_voted_users'] = pd.to_numeric(df_film['num_voted_users'], errors='coerce').astype('Int64')

df_film['rating'] = df_film['rating'].astype(str).str.replace(r'[^a-zA-Z0-9\s]', '', regex=True).str.strip()
df_film['special_features'] = df_film['special_features'].fillna('').astype(str).str.replace(r'[^a-zA-Z0-9\s]', '', regex=True).str.strip()

from google.colab import files

# Guardar el DataFrame limpio en un archivo Excel en el directorio '/content/'
output_file_path = '/content/Cleaned_Film_DataFrame.xlsx'
df_film.to_excel(output_file_path, index=False)

# Descargar el archivo usando la función de Google Colab
files.download(output_file_path)

df_film.info()

sheet_names = ['film', 'inventory', 'rental', 'customer', 'store']
dataframes = {}

file_path = '/content/Films_2.xlsx'  # Ruta para Google Colab

# Cargar el archivo Excel
file_path = '/content/Films_2.xlsx'  # Cambiar a la ubicación de tu archivo en Colab
sheet_names = ["film",'inventory', 'rental', 'customer', 'store']
dataframes = {}

# Cargar todas las hojas y realizar la limpieza
for sheet in sheet_names:
    # Leer la hoja
    df = pd.read_excel(file_path, sheet_name=sheet)

    # Eliminar espacios adicionales en los nombres de las columnas
    df.columns = df.columns.str.strip()

    # Realizar la limpieza de columnas según el formato esperado

    # Identificar si hay columnas numéricas que necesitan limpieza
    for col in df.columns:
        if df[col].dtype == 'object':  # Trabajar con columnas de tipo 'object'
            # Si la columna tiene un nombre que indica que es numérica, año, duración o tasa
            if 'id' in col.lower() or 'year' in col.lower() or 'rate' in col.lower() or 'duration' in col.lower():
                df[col] = df[col].astype(str).str.replace(r'[^0-9]', '', regex=True)
                df[col] = pd.to_numeric(df[col], errors='coerce').astype('Int64')
            # Si la columna podría ser una fecha
            elif 'date' in col.lower() or 'update' in col.lower():
                df[col] = pd.to_datetime(df[col].astype(str).str.replace(r'[^0-9\-: ]', '', regex=True), errors='coerce')
            # Si la columna podría ser flotante
            elif 'cost' in col.lower() or 'rate' in col.lower() or 'length' in col.lower():
                df[col] = df[col].astype(str).str.replace(r'[^0-9.]', '', regex=True)
                df[col] = pd.to_numeric(df[col], errors='coerce').astype(float)
            # Para columnas de texto
            else:
                df[col] = df[col].astype(str).str.replace(r'[^a-zA-Z0-9\s]', '', regex=True).str.strip()

    # Guardar el DataFrame limpio en el diccionario
    dataframes[sheet] = df

for key in dataframes:
    dataframes[key].columns = dataframes[key].columns.str.strip()

df_film = dataframes['film']
df_inventory = dataframes['inventory']
df_rental = dataframes['rental']
df_customer = dataframes['customer']
df_store = dataframes['store']

# Verificar las columnas que tienen cada uno de los DataFrames antes de la unión
print("Film Columns:", df_film.columns)
print("Inventory Columns:", df_inventory.columns)
print("Rental Columns:", df_rental.columns)
print("Customer Columns:", df_customer.columns)
print("Store Columns:", df_store.columns)

# 1. Unir film con inventory usando 'film_id'
df_film_inventory = pd.merge(df_inventory, df_film, how='left', on='film_id', suffixes=('_inventory', '_film'))

# 2. Unir el resultado con rental usando 'inventory_id'
df_film_inventory_rental = pd.merge(df_rental, df_film_inventory, how='left', on='inventory_id', suffixes=('_rental', '_film_inventory'))

# 3. Unir el resultado con customer usando 'customer_id'
# Verificar si 'customer_id_old' existe, y si es así, eliminarla
if 'customer_id_old' in df_customer.columns:
    df_customer = df_customer.drop(columns=['customer_id_old'])  # Eliminamos 'customer_id_old' si existe para evitar problemas

df_film_inventory_rental_customer = pd.merge(df_film_inventory_rental, df_customer, how='left', on='customer_id', suffixes=('_rental', '_customer'))

# Verificar si la columna 'store_id_customer' está presente antes de hacer la última unión
print("Columnas en df_film_inventory_rental_customer:", df_film_inventory_rental_customer.columns)

if 'store_id_customer' in df_film_inventory_rental_customer.columns and 'store_id' in df_store.columns:
    # 4. Finalmente, unir el resultado con store usando 'store_id_customer'
    df_final = pd.merge(df_film_inventory_rental_customer, df_store, how='left', left_on='store_id_customer', right_on='store_id', suffixes=('_customer', '_store'))
else:
    raise KeyError("La columna 'store_id_customer' no se encuentra en df_film_inventory_rental_customer o la columna 'store_id' no se encuentra en df_store.")

# Mostrar información del DataFrame final para verificar
df_final.info()  # Mostrar la información del DataFrame combinado
df_final.head()  # Mostrar las primeras filas para verificar el resultado

df_final.describe()

# Opcional: guardar el DataFrame resultante en un archivo Excel
output_file_path_final = '/content/Final_Combined_DataFrame.xlsx'
df_final.to_excel(output_file_path_final, index=False)

# Descargar el archivo usando la función de Google Colab
from google.colab import files
files.download(output_file_path_final)